/** @babel */
export const CSSColors = {
    "transparent": [0, 0, 0, 0], "aliceblue": [240, 248, 255, 1],
    "antiquewhite": [250, 235, 215, 1], "aqua": [0, 255, 255, 1],
    "aquamarine": [127, 255, 212, 1], "azure": [240, 255, 255, 1],
    "beige": [245, 245, 220, 1], "bisque": [255, 228, 196, 1],
    "black": [0, 0, 0, 1], "blanchedalmond": [255, 235, 205, 1],
    "blue": [0, 0, 255, 1], "blueviolet": [138, 43, 226, 1],
    "brown": [165, 42, 42, 1], "burlywood": [222, 184, 135, 1],
    "cadetblue": [95, 158, 160, 1], "chartreuse": [127, 255, 0, 1],
    "chocolate": [210, 105, 30, 1], "coral": [255, 127, 80, 1],
    "cornflowerblue": [100, 149, 237, 1], "cornsilk": [255, 248, 220, 1],
    "crimson": [220, 20, 60, 1], "cyan": [0, 255, 255, 1],
    "darkblue": [0, 0, 139, 1], "darkcyan": [0, 139, 139, 1],
    "darkgoldenrod": [184, 134, 11, 1], "darkgray": [169, 169, 169, 1],
    "darkgreen": [0, 100, 0, 1], "darkgrey": [169, 169, 169, 1],
    "darkkhaki": [189, 183, 107, 1], "darkmagenta": [139, 0, 139, 1],
    "darkolivegreen": [85, 107, 47, 1], "darkorange": [255, 140, 0, 1],
    "darkorchid": [153, 50, 204, 1], "darkred": [139, 0, 0, 1],
    "darksalmon": [233, 150, 122, 1], "darkseagreen": [143, 188, 143, 1],
    "darkslateblue": [72, 61, 139, 1], "darkslategray": [47, 79, 79, 1],
    "darkslategrey": [47, 79, 79, 1], "darkturquoise": [0, 206, 209, 1],
    "darkviolet": [148, 0, 211, 1], "deeppink": [255, 20, 147, 1],
    "deepskyblue": [0, 191, 255, 1], "dimgray": [105, 105, 105, 1],
    "dimgrey": [105, 105, 105, 1], "dodgerblue": [30, 144, 255, 1],
    "firebrick": [178, 34, 34, 1], "floralwhite": [255, 250, 240, 1],
    "forestgreen": [34, 139, 34, 1], "fuchsia": [255, 0, 255, 1],
    "gainsboro": [220, 220, 220, 1], "ghostwhite": [248, 248, 255, 1],
    "gold": [255, 215, 0, 1], "goldenrod": [218, 165, 32, 1],
    "gray": [128, 128, 128, 1], "green": [0, 128, 0, 1],
    "greenyellow": [173, 255, 47, 1], "grey": [128, 128, 128, 1],
    "honeydew": [240, 255, 240, 1], "hotpink": [255, 105, 180, 1],
    "indianred": [205, 92, 92, 1], "indigo": [75, 0, 130, 1],
    "ivory": [255, 255, 240, 1], "khaki": [240, 230, 140, 1],
    "lavender": [230, 230, 250, 1], "lavenderblush": [255, 240, 245, 1],
    "lawngreen": [124, 252, 0, 1], "lemonchiffon": [255, 250, 205, 1],
    "lightblue": [173, 216, 230, 1], "lightcoral": [240, 128, 128, 1],
    "lightcyan": [224, 255, 255, 1], "lightgoldenrodyellow": [250, 250, 210, 1],
    "lightgray": [211, 211, 211, 1], "lightgreen": [144, 238, 144, 1],
    "lightgrey": [211, 211, 211, 1], "lightpink": [255, 182, 193, 1],
    "lightsalmon": [255, 160, 122, 1], "lightseagreen": [32, 178, 170, 1],
    "lightskyblue": [135, 206, 250, 1], "lightslategray": [119, 136, 153, 1],
    "lightslategrey": [119, 136, 153, 1], "lightsteelblue": [176, 196, 222, 1],
    "lightyellow": [255, 255, 224, 1], "lime": [0, 255, 0, 1],
    "limegreen": [50, 205, 50, 1], "linen": [250, 240, 230, 1],
    "magenta": [255, 0, 255, 1], "maroon": [128, 0, 0, 1],
    "mediumaquamarine": [102, 205, 170, 1], "mediumblue": [0, 0, 205, 1],
    "mediumorchid": [186, 85, 211, 1], "mediumpurple": [147, 112, 219, 1],
    "mediumseagreen": [60, 179, 113, 1], "mediumslateblue": [123, 104, 238, 1],
    "mediumspringgreen": [0, 250, 154, 1], "mediumturquoise": [72, 209, 204, 1],
    "mediumvioletred": [199, 21, 133, 1], "midnightblue": [25, 25, 112, 1],
    "mintcream": [245, 255, 250, 1], "mistyrose": [255, 228, 225, 1],
    "moccasin": [255, 228, 181, 1], "navajowhite": [255, 222, 173, 1],
    "navy": [0, 0, 128, 1], "oldlace": [253, 245, 230, 1],
    "olive": [128, 128, 0, 1], "olivedrab": [107, 142, 35, 1],
    "orange": [255, 165, 0, 1], "orangered": [255, 69, 0, 1],
    "orchid": [218, 112, 214, 1], "palegoldenrod": [238, 232, 170, 1],
    "palegreen": [152, 251, 152, 1], "paleturquoise": [175, 238, 238, 1],
    "palevioletred": [219, 112, 147, 1], "papayawhip": [255, 239, 213, 1],
    "peachpuff": [255, 218, 185, 1], "peru": [205, 133, 63, 1],
    "pink": [255, 192, 203, 1], "plum": [221, 160, 221, 1],
    "powderblue": [176, 224, 230, 1], "purple": [128, 0, 128, 1],
    "red": [255, 0, 0, 1], "rosybrown": [188, 143, 143, 1],
    "royalblue": [65, 105, 225, 1], "saddlebrown": [139, 69, 19, 1],
    "salmon": [250, 128, 114, 1], "sandybrown": [244, 164, 96, 1],
    "seagreen": [46, 139, 87, 1], "seashell": [255, 245, 238, 1],
    "sienna": [160, 82, 45, 1], "silver": [192, 192, 192, 1],
    "skyblue": [135, 206, 235, 1], "slateblue": [106, 90, 205, 1],
    "slategray": [112, 128, 144, 1], "slategrey": [112, 128, 144, 1],
    "snow": [255, 250, 250, 1], "springgreen": [0, 255, 127, 1],
    "steelblue": [70, 130, 180, 1], "tan": [210, 180, 140, 1],
    "teal": [0, 128, 128, 1], "thistle": [216, 191, 216, 1],
    "tomato": [255, 99, 71, 1], "turquoise": [64, 224, 208, 1],
    "violet": [238, 130, 238, 1], "wheat": [245, 222, 179, 1],
    "white": [255, 255, 255, 1], "whitesmoke": [245, 245, 245, 1],
    "yellow": [255, 255, 0, 1], "yellowgreen": [154, 205, 50, 1]
};

const clamp_css_byte = (i) => {
    // Clamp to integer 0 .. 255.
    i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
    return i < 0 ? 0 : i > 255 ? 255 : i;
};

const clamp_css_float = (f) => {  // Clamp to float 0.0 .. 1.0.
    return f < 0 ? 0 : f > 1 ? 1 : f;
};

const parse_css_int = (str) => {  // int or percentage.
    if (str[str.length - 1] === '%')
        return clamp_css_byte(parseFloat(str) / 100 * 255);
    return clamp_css_byte(parseInt(str));
};

const parse_css_float = (str) => {  // float or percentage.
    if (str[str.length - 1] === '%')
        return clamp_css_float(parseFloat(str) / 100);
    return clamp_css_float(parseFloat(str));
};

const css_hue_to_rgb = (m1, m2, h) => {
    if (h < 0) h += 1;
    else if (h > 1) h -= 1;
    if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
    if (h * 2 < 1) return m2;
    if (h * 3 < 2) return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    return m1;
};

export const Transparency = {
    OPAQUE: 1,
    BITMASK: 2,
    TRANSLUCENT: 3
};

const FACTOR = 0.7;

export class Color {

    constructor({r = NaN, g = NaN, b = NaN, a = NaN, rgb = NaN, rgba = NaN, hasalpha = false} = {}) {
        this.falpha = 0.0;
        if (!isNaN(rgba)) {
            this.hasalpha = true;
            this.fromRGBACombinedInt({rgba, hasalpha});
        } else if (!isNaN(rgb)) {
            this.hasalpha = false;
            this.fromRGBCombinedInt({rgb});
        } else if (!isNaN(r) && !isNaN(g) && !isNaN(b) && !isNaN(a)) {
            this.hasalpha = true;
            if ((r >= 0.0 && r <= 1.0) &&
                (g >= 0.0 && g <= 1.0) &&
                (b >= 0.0 && b <= 1.0) &&
                (a >= 0.0 && a <= 1.0)) {
                this.fromRGBAComponentsFloat({r, g, b, a});
            } else {
                this.fromRGBAComponentsInt({r, g, b, a});
            }
        } else if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
            this.hasalpha = false;
            if ((r >= 0.0 && r <= 1.0) &&
                (g >= 0.0 && g <= 1.0) &&
                (b >= 0.0 && b <= 1.0)) {
                this.fromRGBComponentsFloat({r, g, b});
            } else {
                this.fromRGBComponentsInt({r, g, b});
            }
        } else {
            this.hasalpha = false;
            this.fromRGBACombinedInt({
                rgb: 255
            });
        }
    }

    brighter() {
        let r = this.getRed(),
            g = this.getGreen(),
            b = this.getBlue();
        /*
         * From 2D group: 1. black.brighter() should return grey 2.
         * applying brighter to blue will always return blue,
         * brighter 3. non pure color (non zero rgb) will eventually
         * return white
         */
        let i = (1.0 / (1.0 - FACTOR));
        if (r === 0 && g === 0 && b === 0) {
            return new Color({
                r: i,
                g: i,
                b: i
            });
        }
        if (r > 0 && r < i)
            r = i;
        if (g > 0 && g < i)
            g = i;
        if (b > 0 && b < i)
            b = i;
        return new Color({
            r: Math.min((r / FACTOR), 255),
            g: Math.min((g / FACTOR), 255),
            b: Math.min((b / FACTOR), 255)
        });
    }

    static createRGBInstance(rgb = 0) {
        return new Color({rgb: 0xff000000 | rgb});
    }

    static createRGBAInstance(rgba = 0,
                              hasalpha = true) {
        if (hasalpha) {
            return new Color({rgba, hasalpha});
        }
        return Color.createRGBInstance(rgba);
    }

    darker() {
        return new Color({
            r: Math.max((this.getRed() * FACTOR), 0),
            g: Math.max((this.getGreen() * FACTOR), 0),
            b: Math.max((this.getBlue() * FACTOR), 0)
        });
    }

    static decode(color) {
        let str = color.replace(/ /g, '').toLowerCase();
        if (str in CSSColors) {
            let colors = CSSColors[str].slice();
            return new Color({
                r: colors[0],
                g: colors[1],
                b: colors[2]
            });
        }
        if (str[0] === '#') {
            if (color.indexOf("#") !== -1) {
                color = color.replace("#", "0x");
            }
            let i = parseInt(color);
            return new Color({
                r: (i >> 16) & 0xFF,
                g: (i >> 8) & 0xFF,
                b: i & 0xFF
            });
        } else if (str.length === 7) {
            let iv = parseInt(str.substr(1), 16);
            return new Color({
                r: (iv & 0xff0000) >> 16,
                g: (iv & 0xff00) >> 8,
                b: iv & 0xff,
                a: 255
            });
        }
        let op = str.indexOf('('),
            ep = str.indexOf(')');
        if (op !== -1 && ep + 1 === str.length) {
            let fname = str.substr(0, op);
            let params = str.substr(op + 1, ep - (op + 1)).split(',');
            let alpha = 1;
            switch (fname) {
                case 'rgba':
                    alpha = parse_css_float(params.pop());
                    if (alpha >= 0.0 && alpha < 1.0) {
                        alpha = Math.floor(alpha * 255);
                    } else if (alpha === 1) {
                        alpha *= 255;
                    } else {
                        alpha = Math.round(alpha);
                    }
                case 'rgb':
                    return new Color({
                        r: parse_css_int(params[0]),
                        g: parse_css_int(params[1]),
                        b: parse_css_int(params[2]),
                        a: alpha
                    });
                case 'hsla':
                    alpha = parse_css_float(params.pop());
                case 'hsl':
                    let h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;
                    let s = parse_css_float(params[1]);
                    let l = parse_css_float(params[2]);
                    let m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
                    let m1 = l * 2 - m2;
                    return new Color({
                        r: clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255),
                        g: clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                        b: clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255),
                        a: alpha
                    });
            }
        }
    }

    equals(obj) {
        return obj instanceof Color
            && obj.getRGB() === this.getRGB();
    }

    fromRGBACombinedInt({rgba = 0, hasalpha = true} = {}) {
        if (hasalpha) {
            this.value = rgba;
        } else {
            this.value = 0xff000000 | rgba;
        }
    }

    fromRGBCombinedInt({rgb = 0} = {}) {
        this.value = 0xff000000 | rgb;
    }

    fromRGBComponentsFloat({r = 0.0, g = 0.0, b = 0.0} = {}) {
        this.fromRGBAComponentsInt((r * 255 + 0.5),
            (g * 255 + 0.5), (b * 255 + 0.5), 255);
        Color.testColorValueRangeFloat(r, g, b, 1.0);
        this.frgbvalue = new Array(3);
        this.frgbvalue[0] = r;
        this.frgbvalue[1] = g;
        this.frgbvalue[2] = b;
        this.falpha = 1.0;
        this.fvalue = this.frgbvalue;
    }

    fromRGBAComponentsFloat({r = 0.0, g = 0.0, b = 0.0, a = 1} = {}) {
        this.fromRGBAComponentsInt((r * 255 + 0.5),
            (g * 255 + 0.5), (b * 255 + 0.5), (a * 255 + 0.5));
        this.frgbvalue = new Array(3);
        this.frgbvalue[0] = r;
        this.frgbvalue[1] = g;
        this.frgbvalue[2] = b;
        this.falpha = a;
        this.fvalue = this.frgbvalue;
    }

    fromRGBAComponentsInt({r = 0, g = 0, b = 0, a = 255} = {}) {
        this.value = ((0xFF & a) << 24) | ((0xFF & r) << 16) | ((0xFF & g) << 8) | (0xFF & b);
        Color.testColorValueRangeInt(r, g, b, a);
    }

    fromRGBComponentsInt({r = 0, g = 0, b = 0} = {}) {
        let a = 255;
        this.fromRGBAComponentsInt({r, g, b, a});
    }

    getAlpha() {
        return this.getRGB() >>> 24;
    }

    getBlue() {
        return this.getRGB() & 0xFF;
    }

    static getColor(nm, v) {
        let i;
        if (nm) {
            i = parseInt(nm);
        } else {
            return v;
        }
        return new Color({
            r: (i >> 16) & 0xFF,
            g: (i >> 8) & 0xFF,
            b: (i >> 0) & 0xFF
        });
    }

    getColorComponents(compArray = null) {
        if (this.fvalue === null) {
            return this.getRGBColorComponents(compArray);
        }
        let f, n = this.fvalue.length;
        if (compArray === null) {
            f = new Array(n);
        } else {
            f = compArray;
        }
        for (let i = 0; i < n; i++) {
            f[i] = this.fvalue[i];
        }
        return f;
    }

    getComponents(compArray = null) {
        if (!this.fvalue) {
            return this.getRGBComponents(compArray);
        }
        let f, n = this.fvalue.length;
        if (compArray === null) {
            f = new Array(n + 1);
        } else {
            f = compArray;
        }
        for (let i = 0; i < n; i++) {
            f[i] = this.fvalue[i];
        }
        f[n] = this.falpha;
        return f;
    }

    getGreen() {
        return (this.getRGB() >> 8) & 0xFF;
    }

    static getHSBColor(h = 0, s = 0, b = 0) {
        return new Color({
            rgb: Color.HSBtoRGB(h, s, b)
        });
    }

    getRed() {
        return (this.getRGB() >> 16) & 0xFF;
    }

    getRGB() {
        return this.value;
    }

    getRGBColorComponents(compArray = null) {
        let f;
        if (compArray === null) {
            f = new Array(3);
        } else {
            f = compArray;
        }
        if (this.frgbvalue === null) {
            f[0] = (this.getRed()) / 255;
            f[1] = (this.getGreen()) / 255;
            f[2] = (this.getBlue()) / 255;
        } else {
            f[0] = this.frgbvalue[0];
            f[1] = this.frgbvalue[1];
            f[2] = this.frgbvalue[2];
        }
        return f;
    }

    getRGBComponents(compArray = null) {
        let f;
        if (compArray === null) {
            f = new Array(4);
        } else {
            f = compArray;
        }
        if (this.frgbvalue === null) {
            f[0] = (this.getRed()) / 255;
            f[1] = (this.getGreen()) / 255;
            f[2] = (this.getBlue()) / 255;
            f[3] = (this.getAlpha()) / 255;
        } else {
            f[0] = this.frgbvalue[0];
            f[1] = this.frgbvalue[1];
            f[2] = this.frgbvalue[2];
            f[3] = this.falpha;
        }
        return f;
    }

    getTransparency() {
        let alpha = this.getAlpha();
        if (alpha === 0xff) {
            return Transparency.OPAQUE;
        } else if (alpha === 0) {
            return Transparency.BITMASK;
        } else {
            return Transparency.TRANSLUCENT;
        }
    }

    hashCode() {
        return this.value;
    }

    static HSBtoRGB(hue = 0, saturation = 0, brightness = 0) {
        let r = 0, g = 0, b = 0;
        if (saturation === 0) {
            r = g = b = (brightness * 255.0 + 0.5);
        } else {
            let h = (hue - Math.floor(hue)) * 6.0, f = h
                - Math.floor(h), p = brightness
                * (1.0 - saturation), q = brightness
                * (1.0 - saturation * f), t = brightness
                * (1.0 - (saturation * (1.0 - f)));
            switch (h) {
                case 0:
                    r = (brightness * 255.0 + 0.5);
                    g = (t * 255.0 + 0.5);
                    b = (p * 255.0 + 0.5);
                    break;
                case 1:
                    r = (q * 255.0 + 0.5);
                    g = (brightness * 255.0 + 0.5);
                    b = (p * 255.0 + 0.5);
                    break;
                case 2:
                    r = (p * 255.0 + 0.5);
                    g = (brightness * 255.0 + 0.5);
                    b = (t * 255.0 + 0.5);
                    break;
                case 3:
                    r = (p * 255.0 + 0.5);
                    g = (q * 255.0 + 0.5);
                    b = (brightness * 255.0 + 0.5);
                    break;
                case 4:
                    r = (t * 255.0 + 0.5);
                    g = (p * 255.0 + 0.5);
                    b = (brightness * 255.0 + 0.5);
                    break;
                case 5:
                    r = (brightness * 255.0 + 0.5);
                    g = (p * 255.0 + 0.5);
                    b = (q * 255.0 + 0.5);
                    break;
            }
        }
        return 0xff000000 | (r << 16) | (g << 8) | (b << 0);
    }

    static HSVtoRGB(h = 0, s = 0, v = 0) {
        let i, f, p, q, t;
        if (s === 0) {
            return 0xff000000 | (v << 16) | (v << 8) | (v << 0);
        }
        h /= 60;
        i = Math.floor(h);
        f = h - i;
        p = v * (1 - s);
        q = v * (1 - s * f);
        t = v * (1 - s * (1 - f));
        switch (i) {
            case 0:
                return 0xff000000 | (v << 16) | (t << 8) | (p << 0);
            case 1:
                return 0xff000000 | (q << 16) | (v << 8) | (p << 0);
            case 2:
                return 0xff000000 | (p << 16) | (v << 8) | (t << 0);
            case 3:
                return 0xff000000 | (p << 16) | (q << 8) | (v << 0);
            case 4:
                return 0xff000000 | (t << 16) | (p << 8) | (v << 0);
            default:
                return 0xff000000 | (v << 16) | (p << 8) | (q << 0);
        }
    }

    static RGBtoHSB(r = 0, g = 0, b = 0, hsbvals = null) {
        let hue, saturation, brightness;
        if (hsbvals === null) {
            hsbvals = new Array(3);
        }
        let cmax = (r > g) ? r : g;
        if (b > cmax) {
            cmax = b;
        }
        let cmin = (r < g) ? r : g;
        if (b < cmin) {
            cmin = b;
        }
        brightness = cmax / 255.0;
        if (cmax !== 0)
            saturation = ((cmax - cmin)) / cmax;
        else
            saturation = 0;
        if (saturation === 0) {
            hue = 0;
        } else {
            let redc = ((cmax - r)) / ((cmax - cmin)), greenc = ((cmax - g))
                / ((cmax - cmin)), bluec = ((cmax - b))
                / ((cmax - cmin));
            if (r === cmax)
                hue = bluec - greenc;
            else if (g === cmax)
                hue = 2.0 + redc - bluec;
            else
                hue = 4.0 + greenc - redc;
            hue = hue / 6.0;
            if (hue < 0)
                hue = hue + 1.0;
        }
        hsbvals[0] = hue;
        hsbvals[1] = saturation;
        hsbvals[2] = brightness;
        return hsbvals;
    }

    static RGBtoHSV(r = 0, g = 0, b = 0, hsvvals = null) {
        let min, max, delta;
        min = Math.min(r, g, b);
        max = Math.max(r, g, b);
        if (hsvvals === null) {
            hsvvals = new Array(3);
        }
        hsvvals[2] = max;
        delta = max - min;
        if (max !== 0) {
            hsvvals[1] = delta / max;
        } else {
            hsvvals[1] = 0;
            hsvvals[0] = -1;
            return hsvvals;
        }
        if (r === max) {
            hsvvals[0] = (g - b) / delta;
        } else if (g === max) {
            hsvvals[0] = 2 + (b - r) / delta;
        } else {
            hsvvals[0] = 4 + (r - g) / delta;
        }
        hsvvals[0] *= 60;
        if (hsvvals[0] < 0) {
            hsvvals[0] += 360;
        }
        return hsvvals;
    }

    static testColorValueRangeFloat(r, g, b, a) {
        let rangeError = false, badComponentString = "";
        if (a < 0.0 || a > 1.0) {
            rangeError = true;
            badComponentString = badComponentString + " Alpha";
        }
        if (r < 0.0 || r > 1.0) {
            rangeError = true;
            badComponentString = badComponentString + " Red";
        }
        if (g < 0.0 || g > 1.0) {
            rangeError = true;
            badComponentString = badComponentString + " Green";
        }
        if (b < 0.0 || b > 1.0) {
            rangeError = true;
            badComponentString = badComponentString + " Blue";
        }
        if (rangeError) {
            throw new Error("IllegalArgumentException",
                "Color parameter outside of expected range:"
                + badComponentString);
        }
    }

    static testColorValueRangeInt(r, g, b, a) {
        let rangeError = false, badComponentString = "";
        if (a < 0 || a > 255) {
            rangeError = true;
            badComponentString = badComponentString + " Alpha";
        }
        if (r < 0 || r > 255) {
            rangeError = true;
            badComponentString = badComponentString + " Red";
        }
        if (g < 0 || g > 255) {
            rangeError = true;
            badComponentString = badComponentString + " Green";
        }
        if (b < 0 || b > 255) {
            rangeError = true;
            badComponentString = badComponentString + " Blue";
        }
        if (rangeError) {
            throw new Error(
                "IllegalArgumentException Color parameter outside of expected range:"
                + badComponentString);
        }
    }

    toCss() {
        let params = [this.getRed(), this.getGreen(), this.getBlue()].join(",");
        return this.hasalpha ? ["rgba(", params, ",",
            (this.getAlpha() / 255).toFixed(1), ")"].join("") : "rgb(" + params
            + ")";

    }

    toString() {
        return this.constructor.name + "[r=" + this.getRed() + ",g=" + this.getGreen()
            + ",b=" + this.getBlue() + "]";
    }
}

export const white = new Color({
    r: 255,
    g: 255,
    b: 255
});
export const WHITE = white;

export const lightGray = new Color({
    r: 192,
    g: 192,
    b: 192
});
export const LIGHT_GRAY = lightGray;

export const gray = new Color({
    r: 128,
    g: 128,
    b: 128
});
export const GRAY = gray;

export const darkGray = new Color({
    r: 64,
    g: 64,
    b: 64
});
export const DARK_GRAY = darkGray;

export const black = new Color({
    r: 0,
    g: 0,
    b: 0
});
export const BLACK = black;

export const red = new Color({
    r: 255,
    g: 0,
    b: 0
});
export const RED = red;

export const pink = new Color({
    r: 255,
    g: 175,
    b: 175
});
export const PINK = pink;

export const orange = new Color({
    r: 255,
    g: 200,
    b: 0
});
export const ORANGE = orange;

export const yellow = new Color({
    r: 255,
    g: 255,
    b: 0
});
export const YELLOW = yellow;

export const green = new Color({
    r: 0,
    g: 255,
    b: 0
});
export const GREEN = green;

export const magenta = new Color({
    r: 255,
    g: 0,
    b: 255
});
export const MAGENTA = magenta;

export const cyan = new Color({
    r: 0,
    g: 255,
    b: 255
});
export const CYAN = cyan;

export const blue = new Color({
    r: 0,
    g: 0,
    b: 255
});
export const BLUE = blue;

export const transparent = new Color({
    r: 0,
    g: 0,
    b: 0,
    a: 0.0
});
export const TRANSPARENT = transparent;